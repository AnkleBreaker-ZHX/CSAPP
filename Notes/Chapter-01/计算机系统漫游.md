# 计算机系统漫游

## 1. 程序的生命周期

在讲述程序的生命周期时，以下面的hello程序为例

```C
// 一个C语言程序：hello.c
#include <stdio.h>

int main() {
    printf("hello, world\n");
    return 0;
}
```

### 生命周期：创建 -> 编译 -> 运行 -> 结束

书上的说法：被程序员创建 -> 在系统上运行 -> 输出简单的信息 -> 终止

### 1.1. 创建

1. 程序员通过编辑器或IDE等工具创建程序文件（源程序），如hello.c
2. 源程序在计算机中实际上是一串01比特序列，其中8比特=1字节
3. ASCII标准：用一个唯一的单字节大小的整数值来表示每个字符。大部分现代计算机用此来表示文本字符。

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\01-hello.c的ASCII文本表示.png)

(图1：hello.c的ASCII表示)

<strong>基本思想：系统中的所有信息都是由一串比特表示，区分不同数据对象的唯一方法是读到这些数据对象时所处的上下文</strong>

### 1.2. 编译

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\02-编译系统.png)

(图2：编译系统)

* 预处理阶段：根据以字符#开头的命令，修改原始的C程序。在这个例子中，预处理器根据```#include <stdio.h>```读取系统头文件```stdio.h```的内容，并把它直接插入到程序文本中。该阶段的输出通常是以```.i```为后缀名的文件 (hello.i)。
* 编译阶段：编译器将文本文件hello.i翻译成包含汇编语言程序的文本文件hello.s。
* 汇编阶段：汇编器将hello.s翻译成机器语言指令，将指令打包成可重定位目标程序的格式，并将结果保存到目标文件hello.o中。（hello.o为二进制文件，用文本编辑器打开将看到乱码）。
* 链接阶段：hello程序调用了标准C库的函数printf，其存在于预编译好的printf.o文件中。链接器负责将printf.o文件以某种方式合并到hello.o文件中，生成可执行目标文件。可执行目标文件考研被加载到内存中，由系统执行。

#### 了解编译系统的好处

* ##### 优化程序性能

  1. 一个switch语句是否总是比一系列的if-else语句高效得多？
  2. while循环比for循环更加有效吗？
  3. 为什么将循环求和的结果放到一个本地变量中，会比其放到一个通过引用传递过来的参数中，运行起来快很多？
  4. 指针引用比数组索引更有效吗？
  5. 一个函数调用的开销有多大？
  6. 为什么简单重排算术表达式的括号就能让函数运行更快？

* ##### 理解链接时出现的错误

  1. 链接器报告说无法解析一个引用是什么意思？
  2. 静态变量和全局变量的区别是什么？
  3. 在不同的C文件中定义了名字相同的两个全局变量会发生什么？
  4. 静态库与动态库的区别是什么？
  5. 在命令行上排列库的顺序有什么影响？
  6. 为什么有些链接错误知道运行时才会出现？

* ##### 避免安全漏洞

  1. 堆栈原理
  2. 缓冲区溢出

### 1.3. 运行

此时，hello.c源程序已经被编译系统翻译成了可执行目标文件hello，并被存放在磁盘上。

将文件名输入到shell应用程序中（即命令行操作）

```
linux> ./hello
hello, world
linux>
```

随后开始执行以下运行过程

1. 输入字符串"./hello"后，shell程序将字符逐一读入到寄存器，再把它存放到内存中，如图3所示

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\03-在键盘上读取hello命令.png)

(图3：在键盘上读取hello命令)

2. 敲击回车后，shell程序执行一系列指令，将hello目标文件中的代码和数据从磁盘复制到主存，如图4所示

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\04-从磁盘加载可执行文件到主存.png)

(图4：从磁盘加载可执行文件到主存)

3. 加载完成后，处理器开始执行程序中main的机器语言指令，这些指令将"hello world\n"字符串中的字节从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。如图5所示

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\05-从存储器写输出串到显示器.png)

(图5：从存储器写输出串到显示器)

### 1.4. 结束

当加载到主存的目标文件中所有的指令都执行完毕后，程序结束运行。系统释放运行程序时占用的资源





## 2. 计算机体系结构概览

### 2.1. 硬件组成

<strong>1. 总线：贯穿整个系统的一组电子管道，负责携带信息字节并在各个部件之间传递。</strong>

<strong>2. I/O设备：系统与外部世界的联系通道，通过一个控制器或适配器与I/O总线相连。</strong>示例系统的四个I/O设备：键盘和鼠标（输入）、显示器（输出）、磁盘（存储）

* <strong>控制器：</strong>设备本身或系统的主印制电路板
* <strong>适配器：</strong>一块插在主板插槽上的卡
* <strong>区别：封装方式不同</strong>

<strong>3. 主存：一个临时存储设备。在处理器执行程序时，用来存放程序和程序处理的数据。</strong>从物理上来说，由一组动态随机存取存储器（DRAM）组成；从逻辑上来说，存储器是一个线性的字节数组。

<strong>4. 处理器：解释（或执行）存储在主存中指令的引擎。中央处理单元（CPU）的简称。</strong>

* 核心：称为<strong>程序计数器（PC）</strong>的寄存器（大小为一个字的存储设备）
* 工作方式：按照一个指令集架构决定的指令执行模型，读取PC指向的内存中的指令，解释指令中的位并执行相应的操作，然后更新PC使其指向下一条指令（不一定是相邻的指令）。相应的操作围绕着主存、寄存器文件和算术/逻辑单元（ALU）进行。
* 操作举例：
  * <strong>加载：</strong>从主存复制一个字或字节到寄存器，以覆盖寄存器原来的内容
  * <strong>存储：</strong>从寄存器复制一个字或字节到主存的某个位置，以覆盖这个位置原来的内容
  * <strong>操作：</strong>把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器原来的内容
  * <strong>跳转：</strong>从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC原来的值

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\06-一个典型系统的硬件组成.png)

(图6：一个典型的系统硬件组成)



### 2.2. 存储设备的层次结构

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\07-一个存储器层次模型的示例.png)

(图7：存储设备的层次结构)

* 特点：从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节造价越来越便宜。
* <strong>主要思想：上一层的存储器作为下一层存储器的高速缓存。</strong>

#### 2.2.1. 高速缓存

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\08-高速缓存存储器.png)

(图8：高速缓存)

* 问题引入：<strong>系统花费了大量的时间把信息从一个地方移动到另一个地方。</strong>例如hello程序的机器指令最初存放在磁盘上，当程序加载时被复制到主存，当处理器运行程序时从主存被复制到处理器。
* 主要目的：使数据在存储设备各个区域之间的复制、移动等操作尽快完成，减少系统运行的开销。
* 主要思想：<strong>局部性原理：</strong>程序具有访问局部区域里的数据和代码的趋势。
* 主要方法：存放处理器近期可能需要的信息。



### 2.3. 操作系统

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\09-计算机系统的分层视图.png)

(图9：计算机系统的分层视图)

* <strong>基本功能：</strong>
  * （1）防止硬件被失控的应用程序滥用；
  * （2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。比如在shell中输入命令、hello程序的运行和显示输出结果都没有直接访问键盘、显示器和主存。

* <strong>基本抽象概念：</strong>文件（对I/O设备）、虚拟内存（对主存和磁盘I/O设备）、进程（对处理器、主存和I/O设备）

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\10-操作系统提供的抽象表示.png)

(图10：操作系统提供的抽象表示)

#### 2.3.1. 进程

* <strong>定义：进程是操作系统对一个正在运行的程序的一种抽象。</strong>

* <strong>并发运行：</strong>一个进程的指令和另一个进程的指令是交错执行的。
* <strong>上下文：</strong>程序运行所需的所有状态信息。
* <strong>上下文切换：</strong>操作系统实现程序指令交错执行的机制。即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。
* <strong>内核：</strong>操作系统代码常驻主存的部分，是系统管理全部进程所用代码和数据结构的集合。

<strong>示例：进程的上下文切换</strong>

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\11-进程的上下文切换.png)

(图11：进程的上下文切换)

（1）最开始只有shell进程运行，即等待命令行上的输入。

（2）输入执行hello程序的命令后，shell调用一个专门的函数（系统调用）来执行命令。系统调用会将控制权传递给操作系统。

（3）操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传递给hello进程。

（4）hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回。shell进程会继续等待下一条命令的输入。

#### 2.3.2. 线程

* <strong>定义：组成进程的执行单元。</strong>
* 特点：每个线程运行在进程的上下文中，共享相同的代码和全局数据。
* 优点：<strong>多线程比多进程更容易共享数据；一般来说比进程更高效。</strong>

#### 2.3.3. 虚拟内存

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\12-进程的虚拟地址空间.png)

(图12：进程的虚拟地址空间)

<strong>进程的虚拟地址空间的构成</strong>

* <strong>程序代码和数据区。</strong>直接按照可执行目标文件的内容初始化，在进程一开始运行时就被指定了大小；对所有进程来说，代码都是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。
* <strong>运行时堆。</strong>当调用涉及内存分配的C标准库函数（如malloc，free）时，可以在运行时动态地扩展和收缩。
* <strong>共享库。</strong>用来存放像C标准库和数学库这种共享库的代码和数据的区域。
* <strong>用户栈。</strong>编译器用来实现函数调用，在运行时可以动态扩展和收缩。当调用一个函数时，栈会增长；从一个函数返回时，栈会收缩。
* <strong>内核虚拟内存。</strong>为内核保留的区域，不允许应用程序读写该区域的内容或直接调用内核定义的函数。

#### 2.3.4. 文件

* <strong>定义：文件就是字节序列。</strong>
* 作用：向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。
* 范围：每个I/O设备，包括磁盘、键盘、显示器，甚至是网络。



### 2.4. 网络通信

从一个单独的系统来看，<strong>网络可视为一个I/O设备。</strong>

* 当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器。
* 系统可以从网络中读取其他机器发送来的数据，并把数据复制到自己的主存。

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\13-网络也是一种IO设备.png)

(图13：网络也是一种I/O设备)

<strong>利用telnet通过网络远程运行hello程序</strong>

![](F:\GitHub\CSAPP\Notes\Chapter-01\assets\14-利用telnet跨越网络远程运行hello.png)

(图14：利用telnet通过网络远程运行hello程序)





## 3. 重要主题

### 3.1. Amdahl定律

<strong>主要思想：当对系统的某个部分进行加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</strong>

<strong>内容：</strong>

1. 假设系统执行某应用程序需要时间为$T_{old}$
2. 假设系统某部分所需执行时间与该时间的比例为$α$，性能提升比例为$k$。即该部分初始所需时间为$αT_{old}$，现在所需时间为$(αT_{old})/k$。
3. 总执行时间：$T_{new} = (1-α)T_{old}+(αT_{old})/k = T_{old}[(1-α)+α/k]$
4. 加速比：$S = T_{old}/T_{new} = \frac{1}{(1-α)+α/k}$
5. 特别地，当$k→∞$时，$S = \frac{1}{1-α}$

意义：描述了改善任何过程的一般原则，并不局限于计算机领域。



### 3.2. 并发和并行

#### 3.2.1. 线程级并发

#### 3.2.2. 指令级并行

#### 3.3.3. 单指令、多数据并行



### 3.3. 计算机系统中的抽象

计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。

