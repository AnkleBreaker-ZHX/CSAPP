# 信息的表示和处理

## 1. 信息存储

* 大多数计算机使用8位的<strong>块</strong>或<strong>字节</strong>作为最小的可寻址的内存单位，而不是内存中单独的位。
* 机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存。</strong>
* 内存中的每个字节都由一个唯一的数字来标识，称为它的<strong>地址，</strong>所有可能地址的集合称为<strong>虚拟地址空间。</strong>



### 1.1. 十六进制表示法

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\01-十六进制表示法.png)

(图1：十六进制表示法)

* 字符'A' ~ 'F'可以大写、小写，甚至大小写混合。
* 以0x或0X开头的数字常量通常被认为是十六进制的值。

#### 进制的相互转换

<strong>1. 二进制转十六进制：</strong>将二进制数字每4位一组进行划分，最左侧不足4位用0补充。对划分好的每组二进制数字转换成相应的十六进制表示。最后按原来的顺序拼接起来。

<strong>2. 十六进制转二进制：</strong>将每个十六进制数字展开成二进制格式即可。

<strong>3. 十进制转十六进制：</strong>设需要转换的十进制数字为$x$，则可以不断地用$x$除以16，得到一个商$q$和余数$r$，即将$x$表示成$x = 16q + r$的形式。然后使用十六进制表示的$r$作为最低位数字，并通过对$q$反复进行这个过程得到剩下的数字。<strong>下面的例子将十进制的314156转换为十六进制，转换结果为0x4CB2C。</strong>

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\02-十进制转十六进制.png)

(图2：十进制转十六进制)

<strong>4. 十六进制转十进制：</strong>用相应的16的幂去乘每个十六进制的数字。例如0x7AF的十进制值为$7·16^2+10·16^1+15·16^0 = 1967$

<strong>5. 十进制转二进制：</strong>类比十进制转十六进制。

<strong>6. 二进制转十进制：</strong>类比十六进制转十进制。



### 1.2. 字数据大小

* <strong>字长（word size）：</strong>说明一个字有多少位，通常取值为32或64，指明了指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。<strong>对于一个字长为$w$位的机器，虚拟地址范围为$0$~$2^w-1$.</strong>

* 32为字长限制虚拟地址空间为4GB，64位字长则为16EB

* C语言中的一些数据类型

  * 部分数据类型存在平台依赖性。如long类型一般在32位程序中为4字节，在64位程序中为8字节。
  * ```int32_t```和```int64_t```分别为确定的4字节和8字节。类似这种格式的数据类型有固定的大小，不随编译器和机器设置而变化。
  * 大部分数据类型都编码为有符号数值，除非有前缀关键字```unsigned```或对确定大小的数据类型使用了特定的无符号声明
  * <img src="F:\GitHub\CSAPP\Notes\Chapter-02\assets\03-基本C数据类型的典型大小.png" style="zoom:60%;" />

  (图3：基本C数据类型的典型大小)



### 1.3. 寻址和字节顺序

考虑一个$w$位的整数，其位表示为$[x_{w-1},x_{w-2},...,x_{1},x_{0}]$，其中$x_{w-1}$是最高有效位，$x_{0}$是最低有效位。假设$w$是8的倍数，则这些位就能被分组为字节，其中最高有效字节为$[x_{w-1},x_{w-2},...,x_{w-8}]$，最低有效字节为$[x_{7},x_{6},...,x_{0}]$。

* <strong>小端法（little endian）：</strong>从最低有效字节到最高有效字节顺序存储
* <strong>大端法（big endian）：</strong>从最高有效字节到最低有效字节顺序存储

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\04-大端法和小端法.png)



(图4：大端法和小端法)

<strong>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</strong>

#### 需要注意字节顺序的场景

1. 不同类型机器之间通过网络传输二进制数据。
2. 阅读表示整数数据的字节序列。
3. 编写规避正常类型系统的程序（强制类型转换）。

下面的例子展示了不同数据值在不同机器上的表示形式：

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\05-不同数据值的字节表示.png)

(图5：不同数据值的字节表示)



### 1.4. 字符串的表示

* <strong>文本数据比二进制数据具有更强的平台独立性：</strong>确定了字符的编码方式后（如ASCII码），在任何支持该编码方式的系统上都将得到相同的结果。
* 在C语言中，字符串被编码为一个以null（其值为0）字符结尾的字符数组，每个字符都由某个标准编码（如ASCII码）来表示。



### 1.5. 代码的表示

* 从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息。
* 不同的机器类型使用不同的且不兼容的指令和编码方式。
* 即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则。

因此二进制代码是不兼容的，很少能在不同机器和操作系统组合之间移植。



### 1.6. 布尔代数简介

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\06-布尔代数简介.png)

(图6：布尔代数运算)

<strong>运算规则：</strong>

* 非：真假相反
* 与：有假则假
* 或：有真则真
* 异或：同假异真

#### 位向量的布尔运算

假设位向量$a = [a_{w-1}, a_{w-2}, ..., a_{0}]$，$b = [b_{w-1}, b_{w-2}, ..., b_{0}]$，且$\bigodot$表示与、或、异或三种运算之一，则有$a\bigodot b = [a_{w-1}\bigodot b_{w-1}, a_{w-2}\bigodot b_{w-2}, ..., a_{0}\bigodot b_{0}]$。取反运算则是对位向量中的每一位取反。

例：$a = [0110]$，$b = [1100]$，则$a\&b = [0100]$，$a|b = [1110]$，$a\oplus b = [1010]$，~$a = [0011]$。此处$\oplus$表示异或。



### 1.7. 移位运算

假设操作数$x$的位表示为$[x_{w-1}, x_{w-2}, ..., x_{0}]$，则移位运算的操作如下：

* <strong>左移：</strong>$x$向左移动$k$位，丢弃最高的$k$位，并在右端补$k$个$0$，写作$x<<k$。即$x<<k = [x_{w-k-1}, x_{w-k-2}, ..., x_{0}, 0, ..., 0]$。
* <strong>右移：</strong>
  * <strong>算术右移：</strong>$x$向右移动$k$位，丢弃最低的$k$位，并在左端补$k$个最高有效位的值。即结果为$[x_{w-1}, ..., x_{w-1}, x_{w-1}, x_{w-2}, ..., x_{k}]$。对有符号整数的运算非常有用。
  * <strong>逻辑右移：</strong>$x$向右移动$k$位，丢弃最低的$k$位，并在左端补$k$个$0$。即结果为$[0, ..., 0, x_{w-1}, x_{w-2}, ..., x_{k}]$。对无符号数必须使用逻辑右移。

备注：

* 几乎所有的编译器/机器组合都对有符号数使用算术右移，对无符号数使用逻辑右移。
* Java对于如何右移有明确的定义。x>>k指对x进行算术右移，x>>>k指对x进行逻辑右移。



### 拓展：C语言中的相应运算

1. 位级运算：&（按位与）、|（按位或）、^（按位异或）、~（按位取反）。具体运算规则与<strong>位向量的布尔运算</strong>中所写的一致。
2. 逻辑运算：&&（与）、||（或）、^（异或）、~（非）。具体运算规则与<strong>布尔代数</strong>一致。注意逻辑运算认为参数0表示False，其他非零参数都表示True。如果对第一个参数求值就能确定表达式的结果，就不会对第二个参数求值，因此表达式a&&5/a不会造成被零除，表达式p&&*p++不会导致间接引用空指针。
3. 移位运算：x<<k表示将x左移k位，x>>k表示将x右移k位。





## 2. 整数表示

先对这里需要使用到的操作进行约定如下：

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\07-整数的相关操作.png)

(图7：整数的数据与算术操作术语的约定)

### 2.1. 整型数据类型

1. <strong>有符号数：</strong>可以表示正数、负数和零。
2. <strong>无符号数：</strong>只能表示非负数。

备注：

* 计算机对整数的表示都是有限度的。
* 64位机器上表示整数的范围要比32位的大很多。
* 取值范围不对称：负数的范围比正数的范围大1。



### 2.2. 无符号数的编码

定义：对向量$\stackrel{\rightarrow}{x}=[x_{w-1},x_{w-2},...,x_{0}]$：
$$
B2U_{w}(\stackrel{\rightarrow}{x})=\sum_{i=0}^{w-1}x_{i}2^i \tag{2.1}
$$
原理：无符号数编码的唯一性；函数$B2U_{w}$是一个双射。

备注：

* 在向量$\stackrel{\rightarrow}{x}$中，每个$x_{i}$的取值为0或1。$\stackrel{\rightarrow}{x}$可以看作是十进制数$x$的二进制串。
* 函数$B2U_{w}$表示将一个$w$位的二进制串转换为十进制数。
* 函数$U2B_{w}$可以将$0$~$2^{w}-1$之间的每个整数映射位一个唯一的长度为$w$的位模式。
* 双射：一个函数$y=f(x)$将$x$映射到$y$，每个$y$都有唯一一个$x$与之对应。即可以反向操作，通过$y$找到与之对应的$x$



### 2.3. 有符号数的编码

#### 2.3.1. 补码 (Two's-complement)

定义：对向量$\stackrel{\rightarrow}{x}=[x_{w-1},x_{w-2},...,x_{0}]$：
$$
B2T_{w}(\stackrel{\rightarrow}{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^i \tag{2.2}
$$
备注：

1. 最高有效位$x_{w-1}$也称为符号位，"权重"为$-2^{w-1}$，是无符号表示中权重的负数。当符号位为1时，表示值为负；符号位为0时表示值为非负。
2. $w$位补码能表示的值的范围是$[-2^{w-1},2^{w-1}-1]$。其中最小值记作$TMin_{w}=-2^{w-1}$，位向量为$[10...0]$；最大值记作$TMax_{w}=2^{w-1}-1$，位向量为$[01...1]$。<strong>值的范围是不对称的：$|TMin|=|TMax|+1$，$TMin$没有与之对应的正数。原因是一半的位模式表示负数，另一半表示非负数，而0是非负数。</strong>
3. 最大的无符号数值刚好比补码最大值的两倍大一点：$UMax_{w}=2TMax_{w}+1$。
4. $-1$和$UMax$均表示为全1的串；0均表示为全0的串。
5. 补码编码具有唯一性；函数$B2T_{w}$是一个双射。

#### 2.3.2. 反码 (Ones' Complement)

定义：除了最高有效位的权是$-(2_{w-1}-1)$而不是$-2_{w-1}$，它和补码是一样的：
$$
B2O_{w}(\stackrel{\rightarrow}{x})=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_{i}2^i
$$

#### 2.3.3. 原码 (Sign-Magnitude)

定义：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：
$$
B2S_{w}(\stackrel{\rightarrow}{x})=(-1)^{x_{w-1}}\cdot(\sum_{i=0}^{w-2}x_{i}2^i)
$$
备注：

1. <strong>反码和原码对0有两种不同的表示方式：</strong>$[00...0]$被解释为$+0$；值$-0$在原码中表示为$[10...0]$，在反码中表示为$[11...1]$。
2. 补码 (Two's complement) 和反码(Ones' complement) 中撇号的位置不同。



### 2.4. 有符号数和无符号数之间的转换

<strong>一般规则：数值可能会改变，但位模式不变。即改变了解释二进制位的方式。</strong>

#### 2.4.1. 补码转换为无符号数

定义：对满足$TMin_{w}\le x\le TMax_{w}$的$x$有：
$$
\begin{equation}
T2U_{w}(x)=\left\{
	\begin{array}{cl}
		x+2^w，x\textless 0 \\
		x，x\ge 0
	\end{array}
\right.
\end{equation} \tag{2.3}
$$
推导：比较等式(2.1)和等式(2.2)，可以发现$B2U_{w}(\stackrel{\rightarrow}{x})-B2T_{w}(\stackrel{\rightarrow}{x})=x_{w-1}(2^{w-1}-(-2^{w-1}))=x_{w-1}2^w$，即$B2U_{w}(\stackrel{\rightarrow}{x})=x_{w-1}2^w+B2T_{w}(\stackrel{\rightarrow}{x})$。因此有
$$
B2U_{w}(T2B_{w}(x))=T2U_{w}(x)=x+x_{w-1}2^w
$$
在$x$的补码表示中，位$x_{w-1}$决定了$x$是否为负。下图描述了函数$T2U$的一般行为。

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\08-从补码到无符号数的转换.png)

(图8：从补码到无符号数的转换)

#### 2.4.2. 无符号数转换为补码

定义：对满足$0 \le u \le UMax_{w}$的$u$有：
$$
\begin{equation}
U2T_{w}(u)= \left \{
	\begin{array}{cl}
		u，u \le TMax_{w} \\
		u-2_{w}，u \textgreater TMax_{w}
	\end{array}
\right.
\end{equation}
$$
推导：

设$\stackrel{\rightarrow}{u}=U2B_{W}(u)$，这个位向量也是$U2T_{w}(u)$的补码表示。公式(2.1)和公式(2.2)结合起来有
$$
U2T_{w}(u)=-u_{w-1}2^{w}+u
$$
即在$u$的无符号表示中，位$u_{w-1}$决定了$u$是否大于$TMax_{w}=2^{w-1}-1$。下图说明了函数$u2T$的行为。

![](F:\GitHub\CSAPP\Notes\Chapter-02\assets\09-从无符号数到补码的转换.png)

(图9：从无符号数到补码的转换)

